#!/usr/bin/env python
"""
Memory Readback Tool

A frame consists of four sections:
1. One byte for the length of the password.
2. The variable-length password.
3. Four bytes for the start address.
4. Four bytes for the number of bytes to read.

  [ 0x01 ]  [ variable ]  [ 0x04 ]    [ 0x04 ]
-------------------------------------------------
| PW Length | Password | Start Addr | Num Bytes |
-------------------------------------------------
"""

import serial
import struct
import sys
import argparse
import yaml
from math import ceil
import time

import crypto


RESP_OK = b'\x00'
RESP_ERROR = b'\x01'

def construct_request(nonce, start_addr, num_bytes, keys):
    # Refer to our crypto library for signing
    d = crypto.enc_and_sign(struct.pack('>III', nonce, start_addr, num_bytes), keys)
    return d


if __name__ == '__main__':
    keys = ''
    try:
        with open('secret_configure_output.txt', 'rb') as secret_file:
            keys = yaml.load(secret_file)
    except Exception as e:
        print("Could not load secret file")
        print str(e)
        exit()

    parser = argparse.ArgumentParser(description='Memory Readback Tool')

    parser.add_argument("--port", help="Serial port to send update over.",
                        required=True)
    parser.add_argument("--address", help="First address to read from.", type=int,
                        required=True)
    parser.add_argument("--num-bytes", help="Number of bytes to read.", type=int,
                        required=True)
    parser.add_argument("--datafile", help="File to write data to (optional).")
    args = parser.parse_args()

    # Open serial port. Set baudrate to 115200.
    ser = serial.Serial(args.port, baudrate=115200, timeout=300)

    # Request a nonce and wait
    ser.write('\x03')
    while ser.read(1) != 'N':
        pass
    nonce = struct.unpack_from("<I", ser.read(4))[0]

    # Send it into readback mode and wait
    ser.write('\x04')
    while ser.read(1) != 'R':
        pass

    request = construct_request(nonce + 1, args.address, args.num_bytes, keys)
    print "NONCE: ", nonce

    # Send the request.
    ser.write(request[:64])
    time.sleep(0.1)
    ser.write(request[64:])

    # Read the data and write it to stdout (hex encoded).
    enc_data = ser.read(int(ceil(args.num_bytes / 16.0) * 16))
    print 'ENC:', enc_data.encode('hex')
    data = crypto.aes_decrypt(enc_data, keys['firm_key'], keys['firm_iv'])[:args.num_bytes]
    print 'DATA:', data.encode('hex')

    # Write raw data to file (optional).
    if args.datafile:
        with open(args.datafile, 'wb+') as datafile:
            datafile.write(data)
