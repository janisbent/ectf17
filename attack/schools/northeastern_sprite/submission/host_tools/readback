#!/usr/bin/env python
"""
Memory Readback Tool

Readback Steps:
 1. Provisioner sends the requested start address and size to the bootloader.
 2. The bootloader responds back with a random challenge which the provisioner has to solve with the
 shared key in order to authenticate.
 3. The provisioner receieves the random, hashes it along with the secret key and sends the first
 16 bytes of hash to the bootloader.
 4. The bootloader computes the hash using the sent random and its key and mmatches it with the hash
 that was sent. If the 2 match, the user is authenticated.
 5. The bootloader now reads the requested flash area one block at a time (128 MB), encrypts it and
 sends to the provisioner who decrypts it for reading.
"""

import serial
import struct
import argparse
from utils.dce import DCE
from Crypto.Hash import SHA

RESP_OK = b'\x00'  # Bootloader response for a success
RESP_ERROR = b'\x01'  # Bootloader response for an error

MSG_SIZE = 128  # The size of each encrypted message block received


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Memory Readback Tool')

    parser.add_argument("--port", help="Serial port to send update over.", required=True)
    parser.add_argument("--address", help="First address to read from.", required=True)
    parser.add_argument("--num-bytes", help="Number of bytes to read.", required=True)
    parser.add_argument("--datafile", help="File to write data to (optional).")
    args = parser.parse_args()

    ser = serial.Serial(args.port, baudrate=115200, timeout=2)

    # Parameters
    pa = '~\xf0Y\xe0\xd3\x84\xe5$\xe4\x9e\x97_\x9d\xbe>\x8a'  # Public constant a
    pb = '#\x12\xbb/\xa0(\xa9\xd0[5\x89}\xfb\xe6^\xf7'  # Public constant b

    # Load the key
    with open("secret_configure_output.txt", "rb") as f:
        k = f.read()

    try:
        # Wait for the bootloader to enter readback mode
        print('Waiting for bootloader to enter readback mode...')
        while ser.read() != 'R':
            pass
        print('Starting readback')

        # Send the address and number of bytes to the bootloader
        ser.write(struct.pack(">II", int(args.address), int(args.num_bytes)))

        # Receive a random number from the bootloader. To authenticate successfully,
        # hash the key and r and send the auth hash
        r = ser.read(16)

        # Create an instance of the cryptographic library
        c = DCE("rb", k, pa, pb, r)

        # Calculate the hash of the key and the sent random to form the auth hash
        sha = SHA.new()
        sha.update(DCE.xor(k, r))
        h = sha.digest()[:16]
        c.gen_k0(h)

        # Send 16 bytes of the auth hash to the bootloader
        ser.write(h)

        # wait for successful confirmation
        resp = ser.read(1)
        if resp != RESP_OK:
            raise RuntimeError("ERROR: Bootloader responded with {}".format(repr(resp)))

        cipher = ""
        num_blocks = 0
        idx = 0
        # Keep reading till the expected number of blocks are received from the bootloader
        # For each block, send an ack to the bootloader after saving the message
        while num_blocks < int(args.num_bytes):
            print('Reading Frame ' + str(idx))
            d = ser.read(MSG_SIZE)
            num_blocks += MSG_SIZE
            cipher += d
            idx += 1

            # Send acknowledgement back
            ser.write(RESP_OK)

        # Decrypt the message and print
        plain = c.dec(cipher)[:int(args.num_bytes)]
        print plain

        # Write to a file if an output is specified
        if args.datafile:
            with open(args.datafile, 'wb') as f:
                f.write(plain)

    except KeyboardInterrupt:
        ser.close()
        pass
