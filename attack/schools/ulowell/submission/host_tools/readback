#!/usr/bin/env python
"""
Memory Readback Tool

A frame consists of four sections:
1. One byte for the length of the password.
2. The variable-length password.
3. Four bytes for the start address.
4. Four bytes for the number of bytes to read.

  [ 0x01 ]  [ variable ]  [ 0x04 ]    [ 0x04 ]
-------------------------------------------------
| PW Length | Password | Start Addr | Num Bytes |
-------------------------------------------------
"""
import os
import serial
import struct
import sys
import argparse
import time
from Crypto.Cipher import AES

RESP_OK = b'\x00'
RESP_ERROR = b'\x01'

# Set readback request frame. The frame details are shown above
def construct_request(password, start_addr, num_bytes):
    SECRET_PASSWORD = password
    pass_size = len(SECRET_PASSWORD) - 1
    frame_fmt = '>c{}sII'.format(pass_size)

    return struct.pack(frame_fmt, chr(pass_size), SECRET_PASSWORD, start_addr, num_bytes)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Memory Readback Tool')

    parser.add_argument("--port", help="Serial port to send update over.",
                        required=True)
    parser.add_argument("--address", help="First address to read from.",
                        required=True)
    parser.add_argument("--num-bytes", help="Number of bytes to read.",
                        required=True)
    parser.add_argument("--datafile", help="File to write data to (optional).")
    args = parser.parse_args()

    # Read in secret password from file.
    if (os.path.isfile('secret_configure_output.txt')):
        f = open('secret_configure_output.txt','r')
    else:
        f = open('secret_build_output.txt','r')    
    lines = f.readlines()
    f.closed
    key = ''
	
    #Get secret password
    password = lines[0] 
	
    #Get AES decrypt
    for i in lines[1:]:
        key += i    
    
    # Get Number of bytes to read.
    size = int(args.num_bytes) 
  
    # Check the access memory address out of range
    if int(args.address) + size > 0xffff:
	print('ERROR: requeset memory bytes out of range.')
    else:
	pass

    # Package the request data
    request = construct_request(password, int(args.address), size)

    # Open serial port. Set baudrate to 115200. Set timeout to 2 seconds.
    print('Opening serial port...')
    ser = serial.Serial(args.port, baudrate=115200, timeout=2)
    
    # Wait for bootloader to reset/enter readback mode.
    print('Waiting for bootloader to enter readback mode...')
    while ser.read(1) != 'R':
        pass

    # Send the request.
    print('Sending request message...')
    ser.write(request)

	# Wait for bootloader response and save the requested data
    d = ''
    for i in range (0, (size+15) /16):
	resp = ser.read()
        if resp != RESP_OK:
       	    raise RuntimeError("ERROR: Bootloader responded with {}".format(repr(resp)))

        # Read the data and write it to d and prepare for decrypt.
        data = ser.read(16)
       	d += data
	time.sleep(0.1)

    #AES decrypt the received data
    obj = AES.new(key[:16], AES.MODE_ECB)    
    decrypt = ''
    decrypt = obj.decrypt(d)
	
    #print the firmware data
    print('Firmware Data in hex:') 
    print(decrypt[:size].encode('hex'))

    # Write raw data to file (optional).
    if args.datafile:
        with open(args.datafile, 'wb+') as datafile:
            datafile.write(decrypt[:size])
        print 'Output file down.'
