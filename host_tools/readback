#!/usr/bin/env python
"""
Memory Readback Tool

A frame consists of four sections:
1. The variable-length NONCE.
2. Four bytes for the start address.
3. Four bytes for the number of bytes to read.

[ variable ]  [ 0x04 ]       [ 0x04 ]
-------------------------------------------------
| NONCE       | Start Addr | Num Bytes |
-------------------------------------------------
"""

import serial
import struct
import sys
import argparse
import os
from math import ceil
from helpers.Crypt import Crypt

RESP_OK = b'\x00'
RESP_ERROR = b'\x01'
FRAME_SIZE = 512

crypt = Crypt(os.path.abspath(os.path.dirname(__file__)))

def decrypt(cyphertext):
    key = "Hello world!"
    plaintext = ""

    for i in range(len(cyphertext)):
        plaintext += ord(cyphertext[i]) ^ ord(key[i % len(key)])

    return plaintext



def construct_request(start_addr, num_bytes):
    # Read in secret password from file.

    packData = struct.pack('>II', start_addr, num_bytes)

    return crypt.encrypt(packData)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Memory Readback Tool')

    parser.add_argument("--port", help="Serial port to send update over.",
                        required=True)
    parser.add_argument("--address", help="First address to read from.",
                        required=True)

    parser.add_argument("--num-bytes", help="Number of bytes to read.",
                        required=True)
    parser.add_argument("--datafile", help="File to write data to (optional).")
    parser.add_argument("--debug", help="Enable debug messages (optional).", 
                        action="store_true")
    parser.set_defaults(debug=False)

    args = parser.parse_args()

    num_bytes = int(args.num_bytes)

    if args.datafile:
        datafile = open(args.datafile, 'wb+')

    # Open serial port. Set baudrate to 115200. Set timeout to 2 seconds.
    ser = serial.Serial(args.port, baudrate=115200, timeout=2)

    # Wait for bootloader to reset/enter readback mode.
    while ser.read(1) != 'R':
        pass

    # build and encrypt request
#    request = construct_request(int(args.address), int(args.num_bytes))
#    request = crypt.encrypt(request)

    # Send the request.
    ser.write(request)

    # Exit if bootloader rejects request
    if ser.read(1) != RESP_OK:
        sys.exit("Bootloader rejected request")

    # Read the data and write it to stdout (hex encoded).
    for i in range(int(ceil(num_bytes / float(FRAME_SIZE)))):
        # Accept last, impartial frame
        if num_bytes - (i * FRAME_SIZE) < FRAME_SIZE:
            # Print debug message
            if args.debug:
                sys.stderr.write("Reading partial frame: {} bytes\n".format(num_bytes % FRAME_SIZE))
            data = ser.read(num_bytes % FRAME_SIZE)
        # Accept full frame
        else:
            # Print debug message
            if args.debug:
                sys.stderr.write("Reading full frame: {} bytes\n".format(FRAME_SIZE))

            data = ser.read(FRAME_SIZE)
            
#        data = crypt.decode(data)
        data = decrypt(data)
        print(data.encode('hex'))

        # Write raw data to file (optional).
        if args.datafile:
            datafile.write(data)
            
        ser.write(RESP_OKAY)
