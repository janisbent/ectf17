#!/usr/bin/env python
"""
Firmware Bundle-and-Protect Tool

"""
import argparse
import shutil
import struct
import os


from cStringIO import StringIO
from intelhex import IntelHex
from helpers.Crypt import Crypt
from helpers.Crypt import MAX_DATA_SIZE
from math import ceil

FILE_DIR = os.path.abspath(os.path.dirname(__file__))

def encrypt(plaintext):
    key = "Hello world!"

    encryptedData = ""
    for i in range(len(plaintext)):
        encryptedData += str(ord(plaintext[i]) ^ ord(key[i % len(key)]))

    return encryptedData

    

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Firmware Update Tool')

    parser.add_argument("--infile",
                        help="Path to the firmware image to protect.",
                        required=True)
    parser.add_argument("--outfile", help="Filename for the output firmware.",
                        required=True)
    parser.add_argument("--version", help="Version number of this firmware.",
                        required=True)
    parser.add_argument("--message", help="Release message for this firmware.",
                        required=True)
    args = parser.parse_args()

    # Parse Intel hex file.
    firmware = IntelHex(args.infile)

    # Get version and size.
    firmware_size = firmware.maxaddr() + 1
    version = int(args.version)

    # Add release message to end of hex (null-terminated).
    sio = StringIO()
    firmware.putsz(firmware_size, (args.message + '\0'))
    firmware.tobinfile(sio)
    hex_data = sio.getvalue()

    # version, firmware_size, message_size (shorts)
    # crypt = Crypt(FILE_DIR)
    bundleData = struct.pack('>HHH', version, firmware_size, len(args.message) + 1)

    bundleData += hex_data
    #encryptedData = encrypt(bundleData)
    #encryptedData = crypt.encode(bundleData)
    numPackets = 0

#    for i in range(int(ceil(len(hex_data) / float(MAX_DATA_SIZE)))):
#        start = i * MAX_DATA_SIZE
#        end = (i + 1) * MAX_DATA_SIZE
#        #encryptedData += encrypt(hex_data[start:end])
#        # encryptedData += crypt.encode(hex_data[start:end])
#        numPackets += 1

    
    with open(args.outfile, 'wb+') as outfile:
#        outfile.write(encryptedData)
        outfile.write(bundleData)

