#!/usr/bin/env python
"""
Firmware Bundle-and-Protect Tool

"""
import argparse
import shutil
import struct
import json
import zlib
import os
from math import ceil

from cStringIO import StringIO
from intelhex import IntelHex
from helpers.Crypt import Crypt, FRAME_SIZE

FILE_DIR = os.path.abspath(os.path.dirname(__file__))

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Firmware Update Tool')

    parser.add_argument("--infile",
                        help="Path to the firmware image to protect.",
                        required=True)
    parser.add_argument("--outfile", help="Filename for the output firmware.",
                        required=True)
    parser.add_argument("--version", help="Version number of this firmware.",
                        required=True)
    parser.add_argument("--message", help="Release message for this firmware.",
                        required=True)
    args = parser.parse_args()

    # Parse Intel hex file.
    firmware = IntelHex(args.infile)
    crypt = Crypt(FILE_DIR)

    # Get version, size, and nonce.
    firmware_size = firmware.maxaddr() + 1
    version = int(args.version)
    nonce = crypt.getNonce()

    # Pack and encrypt header
    header = struct.pack(">IHH", nonce, version, firmware_size)
    enc_header = crypt.encode(header)

    # The address is not sent, so we currently only support a single segment
    if len(firmware.segments()) > 1:
        raise RuntimeError("ERROR: Hex file contains multiple segments.")

    # starting at address 0.
    for segment_start, segment_end in firmware.segments():
        if segment_start != 0:
            raise RuntimeError("ERROR: Segment in Hex file does not start at address 0.")


    # Add release message to end of hex (null-terminated).
    firmware.putsz(firmware_size, (args.message + '\0'))
    fw =  firmware.tobinstr()

    numFrames = int(ceil(len(fw) / float(FRAME_SIZE)))
    enc_fw = ''

    for i in range(numFrames):
        start = i * FRAME_SIZE
        end = (i + 1) * FRAME_SIZE
        enc_fw += crypt.encode(fw[start : end])

    # Encode the data as json and write to outfile.
    data = {
        'header'   : enc_header.encode('hex'),
        'version'  : version,
        'size'     : firmware_size,
        'data'     : enc_fw.encode('hex')
    }

    with open(args.outfile, 'wb+') as outfile:
        data = json.dumps(data, encoding="ascii")
        #data = zlib.compress(data)
        outfile.write(data)

