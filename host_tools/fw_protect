#!/usr/bin/env python
"""
Firmware Bundle-and-Protect Tool

"""
import argparse
import shutil
import struct
import json
import zlib
import os
from math import ceil

from cStringIO import StringIO
from intelhex import IntelHex
from helpers.Crypt import Crypt, FRAME_SIZE

FILE_DIR = os.path.abspath(os.path.dirname(__file__))

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Firmware Update Tool')

    parser.add_argument("--infile",
                        help="Path to the firmware image to protect.",
                        required=True)
    parser.add_argument("--outfile", help="Filename for the output firmware.",
                        required=True)
    parser.add_argument("--version", help="Version number of this firmware.",
                        required=True)
    parser.add_argument("--message", help="Release message for this firmware.",
                        required=True)
    args = parser.parse_args()

    # Parse Intel hex file.
    firmware = IntelHex(args.infile)
    crypt = Crypt(FILE_DIR)

    # Get version and size.
    firmware_size = firmware.maxad
    version = int(args.version)

    # Add release message to end of hex (null-terminated).
    sio = StringIO()
    firmware.putsz(firmware_size, (args.message + '\00'))
    hex_data = firmware.tobinstr()

    headerStruct = struct.pack('>HHH', firmware_size, len(args.message) + 1, version)

    numFrames = int(ceil(len(hex_data) / float(FRAME_SIZE)))

    with open(args.outfile, 'wb+') as outfile:
        outfile.write(crypt.encode(headerStruct))

        for i in range(numFrames):
            start = i * FRAME_SIZE
            end = (i + 1) * FRAME_SIZE
            data = crypt.encode(hex_data[start : end])

            outfile.write(data)

