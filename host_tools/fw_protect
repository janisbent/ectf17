#!/usr/bin/env python
"""
Firmware Bundle-and-Protect Tool

"""
import argparse
import shutil
import struct
import json
import zlib
import os

from cStringIO import StringIO
from intelhex import IntelHex
from helpers.Crypt import Crypt, FRAME_SIZE

FILE_DIR = os.path.abspath(os.path.dirname(__file__))

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Firmware Update Tool')

    parser.add_argument("--infile",
                        help="Path to the firmware image to protect.",
                        required=True)
    parser.add_argument("--outfile", help="Filename for the output firmware.",
                        required=True)
    parser.add_argument("--version", help="Version number of this firmware.",
                        required=True)
    parser.add_argument("--message", help="Release message for this firmware.",
                        required=True)
    args = parser.parse_args()

    # Parse Intel hex file.
    firmware = IntelHex(args.infile)
    crypt = Crypt(FILE_DIR)

    # Get version, size, and nonce.
    firmware_size = firmware.maxaddr() + 1
    version = int(args.version)
    nonce = Crypt.getNonce()

    # Pack and encrypt header
    header = struct.pack(">IHH", nonce, version, firmware_size)
    enc_header = crypt.encode(header)

    # Add release message to end of hex (null-terminated).
    sio = StringIO()
    firmware.putsz(firmware_size, (args.message + '\0'))
    firmware.write_hex_file(sio)
    hex_data = sio.getvalue()

    numFrames = int(ceil(len(hex_data) / float(FRAME_SIZE)))
    enc_hex_data = ''

    for i in range(numFrames):
        start = i * FRAME_SIZE
        end = (i + 1) * FRAME_SIZE
        enc_hex_data += crypt.encode(hex_data[start : end])

    # Encode the data as json and write to outfile.
    data = {
        'header'   : enc_header,
        'version'  : version,
        'size'     : firmware_size,
        'hex_data' : enc_hex_data
    }

    with open(args.outfile, 'wb+') as outfile:
        data = json.dumps(data)
        data = zlib.compress(data)
        outfile.write(data)

