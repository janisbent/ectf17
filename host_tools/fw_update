#!/usr/bin/env python
"""
Firmware Updater Tool

A frame consists of two sections:
1. Two bytes for the length of the data section
2. A data section of length defined in the length section

[ 0x02 ]  [ variable ]
--------------------
| Length | Data... |
--------------------

In our case, the data is from one line of the Intel Hex formated .hex file

We write a frame to the bootloader, then wait for it to respond with an
OK message so we can write the next frame. The OK message in this case is
just a zero
"""

import argparse
import json
import serial
import struct
import sys
import zlib
import time

from cStringIO import StringIO
from intelhex import IntelHex
from Crypt import MAX_DATA_SIZE

RESP_OK = b'\x00'
RESP_ER = b'\x01'
RESP_AB = b'\xff'

FILE_DIR = os.path.abspath(os.path.dirname(__file__))
 
def readFile(fileName):
    with open(fileName, 'rb') as file:
        data = file.read()
        data = zlib.decompress(data)
        data = json.loads(data)

    return data


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Firmware Update Tool')

    parser.add_argument("--port", help="Serial port to send update over.",
                        required=True)
    parser.add_argument("--firmware", help="Path to firmware image to load.",
                        required=True)
    parser.add_argument("--debug", help="Enable debugging messages.",
                        action='store_true')
    args = parser.parse_args()

    # Open serial port. Set baudrate to 115200. Set timeout to 2 seconds.
    print('Opening serial port...')
    ser = serial.Serial(args.port, baudrate=115200, timeout=2) 

    # Open firmware file.
    print('Opening firmware file...')
    data = readFile(args.firmware)
    print('Version: {}'.format(data.version))
    print('Size: {} bytes (not including release message)'.format(data.firmware_size))

    print('Waiting for bootloader to enter update mode...')
    while ser.read(1) != 'U':
        pass

    for i in range(data.num_packets):
        frame = data.encrypted_data[i * MAX_DATA_SIZE : (i + 1) * MAX_DATA_SIZE]

        if args.debug:
            print("Writing frame {} ({} bytes)...".format(i, len(frame)))

        resp = RESP_ER
        while resp != RESP_OK:
            ser.write(frame)  # Write the frame...

            if args.debug:
                print(frame)

            resp = ser.read()  # Wait for an OK from the bootloader

            time.sleep(0.1)

            if args.debug:
                print("Resp: {}".format(ord(resp)))

            if resp == RESP_AB:
                raise RuntimeError("ERROR: Bootloader responded with {}".format(repr(resp)))
            elif resp == RESP_ER:
                print("Retrying...")

        
    print("Done writing firmware.")

