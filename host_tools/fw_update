#!/usr/bin/env python
"""
Firmware Updater Tool

A frame consists of two sections:
1. Two bytes for the length of the data section
2. A data section of length defined in the length section

[ 0x02 ]  [ variable ]
--------------------
| Length | Data... |
--------------------

In our case, the data is from one line of the Intel Hex formated .hex file

We write a frame to the bootloader, then wait for it to respond with an
OK message so we can write the next frame. The OK message in this case is
just a zero
"""

import argparse
import serial
import struct
import sys
import time
import os

from cStringIO import StringIO
from intelhex import IntelHex
from math import ceil

RESP_OK = b'\x00'
RESP_ER = b'\x01'
RESP_AB = b'\xff'

FILE_DIR = os.path.abspath(os.path.dirname(__file__))
FRAME_SIZE = 512
 
def readFile(fileName):
    with open(fileName, 'rb') as file:
        data = file.read()

    return data

def sendHeader(ser, data, debug):
    print "Writing header...  "

    #print "Should be R: " + ser.read()#################
    #print "Should be R: " + ser.read()#################

    frame = data[0 : FRAME_SIZE]
    #print "Should be S: " + ser.read()#################
    ser.write(frame)
    #print "Should be E: " + ser.read()#################

    # Check valid decryption
    resp = ser.read()
    if resp != RESP_OK:
        raise RuntimeError("ERROR: Bootloader rejected request decrypt: " + resp)

    # Check version pass
    resp = ser.read()
    if resp != RESP_OK:
        raise RuntimeError("ERROR: Bootloader rejected request version: " + resp)

    if debug:
        print "Header accepted!"
        
    #print "Body size: " + ser.read(2).encode('hex')


def sendFrame(ser, data, debug):
    frame = data[(i + 1) * FRAME_SIZE : (i + 2) * FRAME_SIZE].ljust(FRAME_SIZE, '\00')

    if debug:
        print "Writing frame {} ({} bytes)...".format(i, len(frame))

    #print "Should be R: " + ser.read()#################

    resp = RESP_ER
    while resp != RESP_OK:
        #print "Should be S: " + ser.read()#################
        ser.write(frame)  # Write the frame...
        #print "Should be E: " + ser.read()#################

        if debug:
            print(frame).encode('hex')

        resp = ser.read()  # Wait for an OK from the bootloader
    
        if debug:
            print "Response: {}".format(ord(resp))

        time.sleep(0.1)

        if resp == RESP_OK:
            continue
        elif resp == RESP_AB:
            raise RuntimeError("\nERROR: Bootloader responded with {}".format(repr(resp)))
        else:
            print("\tRetrying...")


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Firmware Update Tool')

    parser.add_argument("--port", help="Serial port to send update over.",
                        required=True)
    parser.add_argument("--firmware", help="Path to firmware image to load.",
                        required=True)
    parser.add_argument("--debug", help="Enable debugging messages.",
                        action='store_true')
    args = parser.parse_args()

    # Open serial port. Set baudrate to 115200. Set timeout to 2 seconds.
    print('Opening serial port...')
    ser = serial.Serial(args.port, baudrate=115200, timeout=2) 

    # Open firmware file.
    print('Opening firmware file...')
    data = readFile(args.firmware)

    print('Waiting for bootloader to enter update mode...')
    while ser.read(1) != 'U':
        pass

    # Send header
    sendHeader(ser, data, args.debug)

    numFrames = int(ceil(len(data) / float(FRAME_SIZE))) - 1
    if numFrames == 1:
        print "Writing 1 frame..."
    else:
        print "Writing " + str(numFrames) + " frames (" + str(len(data)) + "bytes)..."

    # Send frames
    for i in range(numFrames):
        sendFrame(ser, data, args.debug)

    while True:
        print ser.read()
        
    print("Done writing firmware.")

